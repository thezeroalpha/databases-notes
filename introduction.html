<html>
<head>
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <title>introduction</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<style type="text/css">
nav a {
    text-align: left;
}
nav #name {
    text-align: right;
    float: right;
    font-style: italic;
}
</style>
    <nav>
    <a href="index.html">Index</a>
    <span id="name">Alex Balgavy</span>
    </nav>
    <hr>
    <div class="content">
    
<div id="Introduction"><h2 id="Introduction" class="header"><a href="#Introduction">Introduction</a></h2></div>
<p>
database: collection of data with
</p>
<ul>
<li>
logical structure

<li>
specific semantics

<li>
specific group of users

</ul>

<p>
Why not in files? There's no query language, a weak logical structure, no efficient access, almost no protection from data loss, no parallel access control.
</p>

<p>
ANSI SPARC architecture stores data in three levels:
</p>
<ol>
<li>
View level: application programs hide details of data types. Hide information for privacy/security

<li>
Logical level ('conceptual schema'): describes data and relations among data

<li>
Physical level: how data is stored, in disk pages, index structures, whatever else.

</ol>

<div id="Introduction-Relational databases"><h3 id="Relational databases" class="header"><a href="#Introduction-Relational databases">Relational databases</a></h3></div>
<p>
view and logical levels are data representations in relations/tables
</p>

<p>
a row is a tuple record. the order of the elements of the tuples doesn't matter.
</p>

<p>
a database instance is a 'snapshot' of a database at a certain point in time.
</p>

<p>
the database schema is the structure of the database - the relations and constraints.
</p>

<p>
constraints:
</p>
<ul>
<li>
primary key (would be underlined) uniquely identifies a row in a table (<code>customer(id, name, street, city)</code>)

<li>
a foreign key that points to a record in a different table (<code>account(depository â†’ customer, accountnr)</code>)

<li>
data types, constrained data types

<li>
columns constraints (e.g. unique, nullability, counter)

<li>
check constraints (logical expression for a domain)

</ul>

<p>
create an entity relationship model in UML:
</p>

<p>
<img src="img/entity-relationship-model.png" alt="Entity relationship model" />
</p>

<p>
then translate that into relations
</p>

<div id="Introduction-Database management system"><h3 id="Database management system" class="header"><a href="#Introduction-Database management system">Database management system</a></h3></div>
<p>
database management system (DBMS) allows:
</p>
<ul>
<li>
create, modify database

<li>
query data using query language (retrieve)

<li>
support persistent storage of large amounts of data

<li>
allow durability and recovery

<li>
control access to data by users in parallel, without unexpected interactions among users (isolation) or partial actions (atomicity)

</ul>

<p>
multiple users, concurrent access. transactions have ACID properties:
</p>
<ul>
<li>
Atomicity: transaction executes fully or not at all (commit/abort)

<li>
Consistency: database remains in a consistent state where all integrity constraints hold

<li>
Isolation: multiple users can modify database at same time but will not see each other's partial actions

<li>
Durability: when a transaction is successfully committed, modified data is persistent regardless of disk crashes

</ul>

<p>
DBMS have data independence and duplication avoidance.
</p>
<ul>
<li>
Logical independence: logical schema doesn't depend on views

<li>
Physical independence: changing physical schema doesn't break the logical schema

</ul>


<div id="Introduction-SQL: Structured Query Language"><h3 id="SQL: Structured Query Language" class="header"><a href="#Introduction-SQL: Structured Query Language">SQL: Structured Query Language</a></h3></div>
<p>
SQL is declarative data manipulation language. The user says which conditions the retrieved data has to fulfill.
</p>

<p>
It's more concise than imperative languages, thus easier to maintain and cheaper to develop programs in it.
</p>

<p>
Users usually don't have to think about efficiency, the DBMS will manage that.
</p>

<p>
Creating a table with constraints:
</p>

<pre>
CREATE TABLE solved (
    id INT AUTO_INCREMENT,
    name VARCHAR(40) NOT NULL,
    homework NUMERIC(2) NOT NULL,
    points NUMERIC(2) NOT NULL CHECK (points &lt;= 10),
    PRIMARY KEY (id)
);
</pre>

<p>
Creating a view:
</p>

<pre>
CREATE VIEW solved_homework AS
    SELECT id, name, homework FROM solved;
</pre>

    </div>
</body>
</html>
